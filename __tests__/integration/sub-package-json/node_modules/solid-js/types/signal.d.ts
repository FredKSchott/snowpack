export declare const equalFn: <T>(a: T, b: T) => boolean;
export declare function createRoot<T>(fn: (dispose: () => void) => T, detachedOwner?: ComputationNode<any>): T;
export declare function createSignal<T>(value?: T, areEqual?: (prev: T, next: T) => boolean): [() => T, (v: T) => void];
export declare function createEffect<T>(fn: (v?: T) => T, value?: T): void;
export declare function createDependentEffect<T>(fn: (v?: T) => T, deps: (() => any) | (() => any)[], defer?: boolean): void;
export declare function createMemo<T>(fn: (v: T | undefined) => T, value?: T, areEqual?: (prev: T, next: T) => boolean): () => T;
export declare function createDeferred<T>(fn: () => T, options?: {
    timeoutMs: number;
}): () => T;
export declare function freeze<T>(fn: () => T): T;
export declare function sample<T>(fn: () => T): T;
export declare function afterEffects(fn: () => void): void;
export declare function onCleanup(fn: (final: boolean) => void): void;
export declare function onError(fn: (err: any) => void): void;
export declare function isListening(): boolean;
export interface Context<T> {
    id: symbol;
    Provider: (props: {
        value: T;
        children: any;
    }) => any;
    defaultValue?: T;
}
export declare function createContext<T>(defaultValue?: T): Context<T>;
export declare function useContext<T>(context: Context<T>): T;
export declare function getContextOwner(): ComputationNode<any> | null;
export declare class DataNode {
    value?: any;
    pending: any;
    log: Log | null;
    constructor(value?: any);
    current(): any;
    next(value: any): any;
}
declare type ComputationNode<T> = {
    fn: ((v: T) => T) | null;
    value: T | undefined;
    comparator: null | ((a: T, b: T) => boolean);
    age: number;
    state: number;
    source1: null | Log;
    source1slot: number;
    sources: null | Log[];
    sourceslots: null | number[];
    dependents: null | (ComputationNode<any> | null)[];
    dependentslot: number;
    dependentcount: number;
    owner: ComputationNode<any> | null;
    log: Log | null;
    context: any;
    owned: ComputationNode<any>[] | null;
    cleanups: ((final: boolean) => void)[] | null;
    afters: ((() => void)[]) | null;
};
declare type Log = {
    node1: null | ComputationNode<unknown>;
    node1slot: number;
    nodes: null | ComputationNode<unknown>[];
    nodeslots: null | number[];
};
export {};
