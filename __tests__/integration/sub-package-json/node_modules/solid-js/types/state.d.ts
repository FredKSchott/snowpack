export declare const SNODE: unique symbol, SPROXY: unique symbol;
export declare type StateNode = {
    [SNODE]?: any;
    [SPROXY]?: any;
    [k: string]: any;
    [k: number]: any;
};
declare type AddSymbolToPrimitive<T> = T extends {
    [Symbol.toPrimitive]: infer V;
} ? {
    [Symbol.toPrimitive]: V;
} : {};
declare type AddCallable<T> = T extends {
    (...x: any[]): infer V;
} ? {
    (...x: Parameters<T>): V;
} : {};
export declare type NotWrappable = string | number | boolean | Function | null;
export declare type Wrapped<T> = {
    [P in keyof T]: T[P] extends object ? Wrapped<T[P]> : T[P];
} & {
    _state?: T;
} & AddSymbolToPrimitive<T> & AddCallable<T>;
declare type StateSetter<T> = Partial<T> | ((prevState: T extends NotWrappable ? T : Wrapped<T>, traversed?: (string | number)[]) => Partial<T> | void);
declare type StatePathRange = {
    from?: number;
    to?: number;
    by?: number;
};
declare type StatePathPart = string | number | (string | number)[] | StatePathRange | ((item: any, index: number) => boolean);
declare type StatePath<T> = [keyof T, StatePathPart, StateSetter<unknown>] | [keyof T, StatePathPart, StatePathPart, StateSetter<unknown>] | [keyof T, StatePathPart, StatePathPart, StatePathPart, StateSetter<unknown>] | [keyof T, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StateSetter<unknown>] | [keyof T, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StateSetter<unknown>] | [keyof T, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StatePathPart, StateSetter<unknown>];
export declare function wrap<T extends StateNode>(value: T, traps?: ProxyHandler<T>): Wrapped<T>;
export declare function isWrappable(obj: any): boolean;
export declare function unwrap<T extends StateNode>(item: any): T;
export declare function getDataNodes(target: StateNode): any;
export declare function setProperty(state: StateNode, property: string | number, value: any, force?: boolean): void;
export declare function updatePath(current: StateNode, path: any[], traversed?: (number | string)[]): void;
export interface SetStateFunction<T> {
    (update: StateSetter<T>): void;
    <A extends keyof T>(part: A, update: StateSetter<T[A]>): void;
    (...path: StatePath<T>): void;
}
export declare function createState<T extends StateNode>(state: T | Wrapped<T>): [Wrapped<T>, SetStateFunction<T>];
export declare function force<T>(value: T | Wrapped<T>): (state: T extends NotWrappable ? T : Wrapped<T>) => void;
export {};
