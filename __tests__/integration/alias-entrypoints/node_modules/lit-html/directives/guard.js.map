{"version":3,"file":"guard.js","sourceRoot":"","sources":["../src/directives/guard.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAO,MAAM,gBAAgB,CAAC;AAE/C,MAAM,cAAc,GAAG,IAAI,OAAO,EAAiB,CAAC;AAEpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AACH,MAAM,CAAC,MAAM,KAAK,GACd,SAAS,CAAC,CAAC,KAAc,EAAE,CAAgB,EAAE,EAAE,CAAC,CAAC,IAAU,EAAQ,EAAE;IACnE,MAAM,aAAa,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/C,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACxB,6BAA6B;QAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC;YAC5B,aAAa,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM;YACrC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE;YACjD,OAAO;SACR;KACF;SAAM,IACH,aAAa,KAAK,KAAK;QACvB,CAAC,KAAK,KAAK,SAAS,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;QACrD,qCAAqC;QACrC,OAAO;KACR;IAED,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IACnB,0EAA0E;IAC1E,iCAAiC;IACjC,cAAc,CAAC,GAAG,CACd,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAC9D,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Part} from '../lit-html.js';\n\nconst previousValues = new WeakMap<Part, unknown>();\n\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * ```\n *\n * In this case, the template only renders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard =\n    directive((value: unknown, f: () => unknown) => (part: Part): void => {\n      const previousValue = previousValues.get(part);\n      if (Array.isArray(value)) {\n        // Dirty-check arrays by item\n        if (Array.isArray(previousValue) &&\n            previousValue.length === value.length &&\n            value.every((v, i) => v === previousValue[i])) {\n          return;\n        }\n      } else if (\n          previousValue === value &&\n          (value !== undefined || previousValues.has(part))) {\n        // Dirty-check non-arrays by identity\n        return;\n      }\n\n      part.setValue(f());\n      // Copy the value if it's an array so that if it's mutated we don't forget\n      // what the previous values were.\n      previousValues.set(\n          part, Array.isArray(value) ? Array.from(value) : value);\n    });\n"]}