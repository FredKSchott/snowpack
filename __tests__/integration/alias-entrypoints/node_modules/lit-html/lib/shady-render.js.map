{"version":3,"file":"shady-render.js","sourceRoot":"","sources":["../src/lib/shady-render.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport {removeNodes} from './dom.js';\nimport {insertNodeIntoTemplate, removeNodesFromTemplate} from './modify-template.js';\nimport {RenderOptions} from './render-options.js';\nimport {parts, render as litRender} from './render.js';\nimport {templateCaches} from './template-factory.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {marker, Template} from './template.js';\n\nexport {html, svg, TemplateResult} from '../lit-html.js';\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type: string, scopeName: string) =>\n    `${type}--${scopeName}`;\n\nlet compatibleShadyCSSVersion = true;\n\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(\n      `Incompatible ShadyCSS version detected. ` +\n      `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n      `@webcomponents/shadycss@1.3.1.`);\n  compatibleShadyCSSVersion = false;\n}\n\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName: string) =>\n    (result: TemplateResult) => {\n      const cacheKey = getTemplateCacheKey(result.type, scopeName);\n      let templateCache = templateCaches.get(cacheKey);\n      if (templateCache === undefined) {\n        templateCache = {\n          stringsArray: new WeakMap<TemplateStringsArray, Template>(),\n          keyString: new Map<string, Template>()\n        };\n        templateCaches.set(cacheKey, templateCache);\n      }\n\n      let template = templateCache.stringsArray.get(result.strings);\n      if (template !== undefined) {\n        return template;\n      }\n\n      const key = result.strings.join(marker);\n      template = templateCache.keyString.get(key);\n      if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n          window.ShadyCSS!.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n      }\n      templateCache.stringsArray.set(result.strings, template);\n      return template;\n    };\n\nconst TEMPLATE_TYPES = ['html', 'svg'];\n\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName: string) => {\n  TEMPLATE_TYPES.forEach((type) => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n    if (templates !== undefined) {\n      templates.keyString.forEach((template) => {\n        const {element: {content}} = template;\n        // IE 11 doesn't support the iterable param Set constructor\n        const styles = new Set<Element>();\n        Array.from(content.querySelectorAll('style')).forEach((s: Element) => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\n\nconst shadyRenderSet = new Set<string>();\n\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles =\n    (scopeName: string, renderedDOM: DocumentFragment, template?: Template) => {\n      shadyRenderSet.add(scopeName);\n      // If `renderedDOM` is stamped from a Template, then we need to edit that\n      // Template's underlying template element. Otherwise, we create one here\n      // to give to ShadyCSS, which still requires one while scoping.\n      const templateElement =\n          !!template ? template.element : document.createElement('template');\n      // Move styles out of rendered DOM and store.\n      const styles = renderedDOM.querySelectorAll('style');\n      const {length} = styles;\n      // If there are no styles, skip unnecessary work\n      if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn't support @apply at all.\n        window.ShadyCSS!.prepareTemplateStyles(templateElement, scopeName);\n        return;\n      }\n      const condensedStyle = document.createElement('style');\n      // Collect styles into a single style. This helps us make sure ShadyCSS\n      // manipulations will not prevent us from being able to fix up template\n      // part indices.\n      // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n      // currently does this anyway. When it does not, this should be changed.\n      for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode!.removeChild(style);\n        condensedStyle.textContent! += style.textContent;\n      }\n      // Remove styles from nested templates in this scope.\n      removeStylesFromLitTemplates(scopeName);\n      // And then put the condensed style into the \"root\" template passed in as\n      // `template`.\n      const content = templateElement.content;\n      if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n      } else {\n        content.insertBefore(condensedStyle, content.firstChild);\n      }\n      // Note, it's important that ShadyCSS gets the template that `lit-html`\n      // will actually render so that it can update the style inside when\n      // needed (e.g. @apply native Shadow DOM case).\n      window.ShadyCSS!.prepareTemplateStyles(templateElement, scopeName);\n      const style = content.querySelector('style');\n      if (window.ShadyCSS!.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n      } else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set<Node>();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n      }\n    };\n\nexport interface ShadyRenderOptions extends Partial<RenderOptions> {\n  scopeName: string;\n}\n\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nexport const render =\n    (result: unknown,\n     container: Element|DocumentFragment|ShadowRoot,\n     options: ShadyRenderOptions) => {\n      if (!options || typeof options !== 'object' || !options.scopeName) {\n        throw new Error('The `scopeName` option is required.');\n      }\n      const scopeName = options.scopeName;\n      const hasRendered = parts.has(container);\n      const needsScoping = compatibleShadyCSSVersion &&\n          container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n          !!(container as ShadowRoot).host;\n      // Handle first render to a scope specially...\n      const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n      // On first scope render, render into a fragment; this cannot be a single\n      // fragment that is reused since nested renders can occur synchronously.\n      const renderContainer =\n          firstScopeRender ? document.createDocumentFragment() : container;\n      litRender(\n          result,\n          renderContainer,\n          {templateFactory: shadyTemplateFactory(scopeName), ...options} as\n              RenderOptions);\n      // When performing first scope render,\n      // (1) We've rendered into a fragment so that there's a chance to\n      // `prepareTemplateStyles` before sub-elements hit the DOM\n      // (which might cause them to render based on a common pattern of\n      // rendering in a custom element's `connectedCallback`);\n      // (2) Scope the template with ShadyCSS one time only for this scope.\n      // (3) Render the fragment into the container and make sure the\n      // container knows its `part` is the one we just rendered. This ensures\n      // DOM will be re-used on subsequent renders.\n      if (firstScopeRender) {\n        const part = parts.get(renderContainer)!;\n        parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(\n            scopeName, renderContainer as DocumentFragment, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        parts.set(container, part);\n      }\n      // After elements have hit the DOM, update styling if this is the\n      // initial render to this container.\n      // This is needed whenever dynamic changes are made so it would be\n      // safest to do every render; however, this would regress performance\n      // so we leave it up to the user to call `ShadyCSS.styleElement`\n      // for dynamic changes.\n      if (!hasRendered && needsScoping) {\n        window.ShadyCSS!.styleElement((container as ShadowRoot).host);\n      }\n    };\n"]}