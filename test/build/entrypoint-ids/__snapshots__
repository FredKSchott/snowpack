// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`snowpack build entrypoint-ids: allFiles 1`] = `
Array [
  "__snowpack__/env.js",
  "_dist_/index.js",
  "web_modules/ansi-styles.js",
  "web_modules/chalk.js",
  "web_modules/import-map.json",
]
`;

exports[`snowpack build entrypoint-ids: build/__snowpack__/env.js 1`] = `"export default {\\"MODE\\":\\"production\\",\\"NODE_ENV\\":\\"production\\",\\"SSR\\":false};"`;

exports[`snowpack build entrypoint-ids: build/_dist_/index.js 1`] = `
"import '../web_modules/chalk.js';
import '../web_modules/ansi-styles.js';"
`;

exports[`snowpack build entrypoint-ids: build/web_modules/ansi-styles.js 1`] = `
"import { a as ansiStyles } from './common/index-XXXXXXXX.js';
export { a as __moduleExports, a as default } from './common/index-XXXXXXXX.js';
var bgBlack = ansiStyles.bgBlack;
var bgBlackBright = ansiStyles.bgBlackBright;
var bgBlue = ansiStyles.bgBlue;
var bgBlueBright = ansiStyles.bgBlueBright;
var bgCyan = ansiStyles.bgCyan;
var bgCyanBright = ansiStyles.bgCyanBright;
var bgGray = ansiStyles.bgGray;
var bgGreen = ansiStyles.bgGreen;
var bgGreenBright = ansiStyles.bgGreenBright;
var bgGrey = ansiStyles.bgGrey;
var bgMagenta = ansiStyles.bgMagenta;
var bgMagentaBright = ansiStyles.bgMagentaBright;
var bgRed = ansiStyles.bgRed;
var bgRedBright = ansiStyles.bgRedBright;
var bgWhite = ansiStyles.bgWhite;
var bgWhiteBright = ansiStyles.bgWhiteBright;
var bgYellow = ansiStyles.bgYellow;
var bgYellowBright = ansiStyles.bgYellowBright;
var black = ansiStyles.black;
var blackBright = ansiStyles.blackBright;
var blue = ansiStyles.blue;
var blueBright = ansiStyles.blueBright;
var bold = ansiStyles.bold;
var cyan = ansiStyles.cyan;
var cyanBright = ansiStyles.cyanBright;
var dim = ansiStyles.dim;
var gray = ansiStyles.gray;
var green = ansiStyles.green;
var greenBright = ansiStyles.greenBright;
var grey = ansiStyles.grey;
var hidden = ansiStyles.hidden;
var inverse = ansiStyles.inverse;
var italic = ansiStyles.italic;
var magenta = ansiStyles.magenta;
var magentaBright = ansiStyles.magentaBright;
var red = ansiStyles.red;
var redBright = ansiStyles.redBright;
var reset = ansiStyles.reset;
var strikethrough = ansiStyles.strikethrough;
var underline = ansiStyles.underline;
var white = ansiStyles.white;
var whiteBright = ansiStyles.whiteBright;
var yellow = ansiStyles.yellow;
var yellowBright = ansiStyles.yellowBright;
export { bgBlack, bgBlackBright, bgBlue, bgBlueBright, bgCyan, bgCyanBright, bgGray, bgGreen, bgGreenBright, bgGrey, bgMagenta, bgMagentaBright, bgRed, bgRedBright, bgWhite, bgWhiteBright, bgYellow, bgYellowBright, black, blackBright, blue, blueBright, bold, cyan, cyanBright, dim, gray, green, greenBright, grey, hidden, inverse, italic, magenta, magentaBright, red, redBright, reset, strikethrough, underline, white, whiteBright, yellow, yellowBright };"
`;

exports[`snowpack build entrypoint-ids: build/web_modules/chalk.js 1`] = `
"import { a as ansiStyles } from './common/index-XXXXXXXX.js';
var browser = {
	stdout: false,
	stderr: false
};
const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string.substr(endIndex);
	return returnValue;
};
const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\\\\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '' : '') + postfix;
		endIndex = index + 1;
		index = string.indexOf('', endIndex);
	} while (index !== -1);
	returnValue += string.substr(endIndex);
	return returnValue;
};
var util = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};
const TEMPLATE_REGEX = /(?:\\\\\\\\(u(?:[a-f\\\\d]{4}|\\\\{[a-f\\\\d]{1,6}\\\\})|x[a-f\\\\d]{2}|.))|(?:\\\\{(~)?(\\\\w+(?:\\\\([^)]*\\\\))?(?:\\\\.\\\\w+(?:\\\\([^)]*\\\\))?)*)(?:[ \\\\t]|(?=\\\\r?)))|(\\\\})|((?:.|[\\\\f])+?)/gi;
const STYLE_REGEX = /(?:^|\\\\.)(\\\\w+)(?:\\\\(([^)]*)\\\\))?/g;
const STRING_REGEX = /^(['\\"])((?:\\\\\\\\.|(?!\\\\1)[^\\\\\\\\])*)\\\\1$/;
const ESCAPE_REGEX = /\\\\\\\\(u(?:[a-f\\\\d]{4}|{[a-f\\\\d]{1,6}})|x[a-f\\\\d]{2}|.)|([^\\\\\\\\])/gi;
const ESCAPES = new Map([
	['n', ''],
	['r', '\\\\r'],
	['t', '\\\\t'],
	['b', '\\\\b'],
	['f', '\\\\f'],
	['v', '\\\\v'],
	['0', '\\\\0'],
	['\\\\\\\\', '\\\\\\\\'],
	['e', '\\\\u001B'],
	['a', '\\\\u0007']
]);
function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';
	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}
	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}
	return ESCAPES.get(c) || c;
}
function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\\\\s*,\\\\s*/g);
	let matches;
	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(\`Invalid Chalk template style argument: \${chunk} (in style '\${name}')\`);
		}
	}
	return results;
}
function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;
	const results = [];
	let matches;
	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];
		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}
	return results;
}
function buildStyle(chalk, styles) {
	const enabled = {};
	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}
	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}
		if (!(styleName in current)) {
			throw new Error(\`Unknown Chalk style: \${styleName}\`);
		}
		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}
	return current;
}
var templates = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];
	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}
			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});
	chunks.push(chunk.join(''));
	if (styles.length > 0) {
		const errMessage = \`Chalk template literal is missing \${styles.length} closing bracket\${styles.length === 1 ? '' : 's'} (\\\\\`}\\\\\`)\`;
		throw new Error(errMessage);
	}
	return chunks.join('');
};
const {stdout: stdoutColor, stderr: stderrColor} = browser;
const {
	stringReplaceAll: stringReplaceAll$1,
	stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
} = util;
const {isArray} = Array;
// \`supportsColor.level\` â†’ \`ansiStyles.color[name]\` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The \`level\` option should be an integer from 0 to 3');
	}
	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}
const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);
	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);
	chalk.template.constructor = () => {
		throw new Error('\`chalk.constructor()\` is deprecated. Use \`new chalk.Instance()\` instead.');
	};
	chalk.template.Instance = ChalkClass;
	return chalk.template;
};
function Chalk(options) {
	return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}
styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};
const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}
for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}
const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}
	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};
const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red\`2 + 3 = {bold \${2+3}}\`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}
		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};
	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);
	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;
	return builder;
};
const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}
	let styler = self._styler;
	if (styler === undefined) {
		return string;
	}
	const {openAll, closeAll} = styler;
	if (string.indexOf('\\\\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll$1(string, styler.close, styler.open);
			styler = styler.parent;
		}
	}
	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex$1(string, closeAll, openAll, lfIndex);
	}
	return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;
	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}
	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];
	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\\\\\\\]/g, '\\\\\\\\$&'),
			String(firstString.raw[i])
		);
	}
	if (template === undefined) {
		template = templates;
	}
	return template(chalk, parts.join(''));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;
var source = chalk;
export default source;"
`;

exports[`snowpack build entrypoint-ids: build/web_modules/import-map.json 1`] = `
"{
  \\"imports\\": {
    \\"ansi-styles\\": \\"./ansi-styles.js\\",
    \\"chalk\\": \\"./chalk.js\\"
  }
}"
`;
